import { parseArgs } from 'util';

export type Deployment = {
  contractName: string;
  contractAddress: `0x${string}`;
  hash: `0x${string}`;
  arguments: `0x${string}`[];  
  commit: `0x${string}`;
  timestamp: number;
};

export type Tracker = {
  chainId: string;
  deployments: Deployment[];
};

(async () => {
  const { values } = parseArgs({
    args: Bun.argv,
    options: {
      chainId: {
        type: 'string',
      },
      script: {
        type: 'string',
      },
    },
    strict: true,
    allowPositionals: true,
  });

  // We open the broadcast file generated by Foundry
  const path = `broadcast/${values.script}.s.sol/${values.chainId}/run-latest.json`;
  const file = Bun.file(path);

  const broadcast: {
    transactions: Deployment[];
    commit: `0x${string}`;
    timestamp: number;
  } = await file.json();

  const deployments: Deployment[] = broadcast.transactions
    .filter((transaction: Deployment & {transactionType: 'CREATE' | 'CALL'}) => transaction.transactionType === 'CREATE')
    .map((transactions: Deployment) => ({
      contractName: transactions.contractName,
      contractAddress: transactions.contractAddress,
      hash: transactions.hash,
      arguments: transactions.arguments,
      commit: broadcast.commit,
      timestamp: broadcast.timestamp,
    }));

  // Then we generate the json file with the deployments history
  const tracker = Bun.file(`deployments/${values.chainId}.json`);
  let trackerContent: Tracker;

  if (await tracker.exists()) {
    trackerContent = await tracker.json();
    trackerContent.deployments.push(...deployments);
  } else {
    trackerContent = {
      chainId: values.chainId,
      deployments,
    };
  }

  // And we save it!
  await Bun.write(
    `deployments/${values.chainId}.json`,
    JSON.stringify(trackerContent, null, 2),
  );
})();