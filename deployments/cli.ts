import { parseArgs } from 'util';
import { readdirSync } from 'node:fs';

type ChainDetails = {
  name: string;
  explorerUrl: string;
}

export const chains: {[chainId: string]: ChainDetails } = {
  '8453': {
    name: 'Base',
    explorerUrl: 'https://basescan.org',
  },
  '84532': {
    name: 'Base Sepolia',
    explorerUrl: 'https://sepolia.basescan.org',
  },
  '130': {
    name: 'Unichain',
    explorerUrl: 'https://uniscan.xyz',
  },
  '1301': {
    name: 'Unichain Sepolia',
    explorerUrl: 'https://sepolia.uniscan.xyz/',
  },
  '57073': {
    name: 'Ink',
    explorerUrl: 'https://explorer.inkonchain.com/',
  },
  '763373': {
    name: 'Ink Sepolia',
    explorerUrl: 'https://explorer-sepolia.inkonchain.com/',
  },
};

export type Deployment = {
  contractName: string;
  contractAddress: `0x${string}`;
  hash: `0x${string}`;
  arguments: `0x${string}`[];  
  commit: `0x${string}`;
  timestamp: number;
};

export type Tracker = {
  chainId: string;
  deployments: Deployment[];
};

function shorten(a: string, length: number = 4): string {
  return `${a.slice(0, length + 2)}...${a.slice(-length)}`;
}

export function generateTable(deployments: Deployment[], chainId: string): string {
  const explorerUrl = chains[chainId].explorerUrl;

  let content = `| Contract | Address | Transaction | Commit |\n`;
  content += '|---|---|---|---|\n';

  deployments.forEach((d) => {
    content += `| ${d.contractName}`;
    content += ` | [${shorten(d.contractAddress)}](${explorerUrl}/address/${d.contractAddress})`;
    content += ` | [${shorten(d.hash, 4)}](${explorerUrl}/tx/${d.hash})`;
    content += ` | [${d.commit.slice(0, 8)}](https://github.com/whetstoneresearch/doppler/commit/${d.commit})`;
    content += ` | \n`;
  });

  return content;
}

export function getLatestDeployments(tracker: Tracker): Deployment[] {
  const latestDeployments: {[key: string]: Deployment} = {};

  tracker.deployments.forEach((deployment) => {
    if (!latestDeployments[deployment.contractName]) {
      latestDeployments[deployment.contractName] = deployment;
    } else {
      if (latestDeployments[deployment.contractName].timestamp < deployment.timestamp) {
        latestDeployments[deployment.contractName] = deployment;
      }
    }
  });

  return Object.values(latestDeployments);
}

async function generateLogs(chainId: string, script: string): Promise<void> {
    // We open the broadcast file generated by Foundry
  const path = `broadcast/${script}.s.sol/${chainId}/run-latest.json`;
  const file = Bun.file(path);

  const broadcast: {
    transactions: Deployment[];
    commit: `0x${string}`;
    timestamp: number;
  } = await file.json();

  const deployments: Deployment[] = broadcast.transactions
    .filter((transaction: Deployment & {transactionType: 'CREATE' | 'CALL'}) => transaction.transactionType === 'CREATE')
    .map((transactions: Deployment) => ({
      contractName: transactions.contractName,
      contractAddress: transactions.contractAddress,
      hash: transactions.hash,
      arguments: transactions.arguments,
      commit: broadcast.commit,
      timestamp: broadcast.timestamp,
    }));

  // Then we generate the json file with the deployments history
  const tracker = Bun.file(`deployments/${chainId}.json`);
  let trackerContent: Tracker;

  if (await tracker.exists()) {
    trackerContent = await tracker.json();
    trackerContent.deployments.push(...deployments);
  } else {
    trackerContent = {
      chainId,
      deployments,
    };
  }

  // And we save it!
  await Bun.write(
    `deployments/${chainId}.json`,
    JSON.stringify(trackerContent, null, 2),
  );
}

async function generateDocs(chainId: string): Promise<void> {
    // Let's open the deployments tracker for the specified chain
  const file = Bun.file(`deployments/${chainId}.json`);
  const tracker = await file.json() as Tracker;
  
  let content = `# Deployments on ${chains[chainId].name} (${chainId})\n`;


  // We start by making a nice table for the latest deployments
  content += `## Latest deployments\n`;

  const latestDeployments = getLatestDeployments(tracker);
  content += generateTable(latestDeployments, chainId);

  // Then we're making a list of historical deployments
  content += `## History\n`;

  let timestamps: {[key: number]: Deployment[]} = {};

  tracker.deployments.forEach((d) => {
    if (!timestamps[d.timestamp]) {
      timestamps[d.timestamp] = [];
    }
    timestamps[d.timestamp].push(d);
  });

  for (let i = Object.values(timestamps).length - 1; i >= 0; i--) {
    const t = Object.values(timestamps)[i];

    content += `### ${new Date(t[0].timestamp).toUTCString()}\n`;
    content += generateTable(t, chainId);
  }

  // And we save the file!
  await Bun.write(
    `deployments/${chainId}.md`,
    content,
  );
}

const finalDocsTemplate = `---
icon: pen-field
---

# Contract addresses

Here are the networks that Doppler is officially deployed to:

- Mainnets: Unichain Mainnet, Ink Mainnet
- Testnets: Unichain Sepolia, Base Sepolia, Ink Sepolia, Monad Testnet&#x20;

{% hint style="danger" %}
If there are contracts not reflected here but claiming to be instances of Doppler, they are not considered canonical. Use with caution. :rotating_light:
{% endhint %}\n`;

async function generateFinalDocs(): Promise<void> {
  const fileList = readdirSync('./deployments');
  const deploymentFiles = fileList
    .filter((file) => file.endsWith('.json'));

  let content = finalDocsTemplate;

  for (const file of deploymentFiles) {
    const filePath = `./deployments/${file}`;
    const raw = Bun.file(filePath);
    const tracker = await raw.json() as Tracker;
    const deployments = getLatestDeployments(tracker);
    content += `\n## ${chains[tracker.chainId].name} (${tracker.chainId})\n\n`;
    content += generateTable(deployments, tracker.chainId);
  };

  await Bun.write(
    `./Deployments.md`,
    content,
  );
}

async function main() {
  const { values } = parseArgs({
    args: Bun.argv,
    options: {
      output: {
        type: 'string',
      },
      chainId: {
        type: 'string',
      },
      script: {
        type: 'string',
      },
    },
    strict: true,
    allowPositionals: true,
  });

  switch (values.output) {
    case 'json':
      await generateLogs(values.chainId, values.script);
      break;
    case 'markdown':
      await generateDocs(values.chainId);
      break;
    case 'docs':
      await generateFinalDocs();
      break;
    default:
      console.error(`Unknown command: ${values.output}`);
      process.exit(1);
  }
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});